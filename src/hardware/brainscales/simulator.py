from pyNN import common

name = "HardwareBrainscales"

class ID(int,common.IDMixin):
    """!
    An integer ID that stores additional information about PyNN cells.

    An integer ID that stores additional information about PyNN cells
    like e.g. their corresponding node in the GraphModel.

    @param int - ...
    @param common.IDMixin - ...

    Instead of storing ids as integers, we store them as ID objects,
    which allows a syntax like:
        p[3,4].tau_m = 20.0
    where p is a Population object.

    The question is, how big a memory/performance hit is when replacing integers with ID objects?

    Hardware specific:

        The additional member .cell is of type:
            EIF_cond_alpha_isfa_ista, IF_cond_exp_gsfa_grr, SpikeSourcePoisson or SpikeSourceArray
            It is generated by create() automatically.

        The additional members graphModelNode and graphModelNodeParams are also stored to keep
        track of this ID within the GraphModel.
    """

    non_parameter_attributes = ('parent', '_cellclass', 'cellclass',
                                '_position', 'position', 'hocname', '_cell',
                                'inject', '_v_init', 'local','graphModelNode',
                                'graphModelNodeParams','tag', 'has_spikes', 'local', 'posX', 'posY', 'posZ', 'rgba')

    def __init__(self, index, cell, graphModelNode=None, graphModelNodeParams=None, **extra_params):
        """!
        Constructor of class ID.

            @param index                - an integer defining the base class value of this ID.
            @param cell                 - a reference to the PyNN cell this ID is associated with.
            @param graphModelNode       - a reference to the GraphModel node this ID is associated with.
            @param graphModelNodeParams - a reference to the GraphModel parameter node this ID is associated with.
            @param extra_params         - any keyword arguments that are required by this PyNN back-end but not by others.
                                          Currently supported:
                                              @param id_tag     - a string that helps to identify this cell within the GraphModel.
                                              @param has_spikes - a boolean that indicates if this object owns stimulation spikes
        """

        int.__init__(index)
        common.IDMixin.__init__(self)
        object.__setattr__(self,'cell',cell)
        self.cellclass = cell.__class__
        self.graphModelNode = graphModelNode
        self.graphModelNodeParams = graphModelNodeParams
        if 'id_tag' in extra_params.keys():
            toLog(DEBUG0, 'Adding tag ' + str(extra_params['id_tag']) + ' to cell ' + self.__str__())
            self.tag = extra_params['id_tag']
        if 'has_spikes' in extra_params.keys():
            self.has_spikes = extra_params['has_spikes']
        else: self.has_spikes = False

    def __new__(cls, index, cell, graphModelNode, graphModelNodeParams, **extra_params):
        inst = super(ID, cls).__new__(cls, index)
        return inst

    def __getattr__(self, name):
        if self.cell.parameters.has_key(name):
            return self.cell.parameters[name]
        else:
            return object.__getattribute__(self,name)

    def __setattr__(self,name,value):
        if name == 'position':
            self.graphModelNode.posX = value[0]
            self.graphModelNode.posY = value[1]
            self.graphModelNode.posZ = value[2]
        if name == 'rgba':
            self.graphModelNode.colR = value[0]
            self.graphModelNode.colG = value[1]
            self.graphModelNode.colB = value[2]
            self.graphModelNode.colA = value[3]
        if name in ID.non_parameter_attributes or not self.is_standard_cell():
            object.__setattr__(self, name, value)
        else:
            return self.set_parameters(**{name:value})


    def set_native_parameters(self, parameters):
        """!
        Set parameters of the hardware cell model from a dictionary.
        """

        self.cell.parameters.update(parameters)

    def get_native_parameters(self):
        """!
        Get parameters of the hardware cell model from a dictionary.
        """

        return self.cell.parameters

class State(common.control.BaseState):
    """!
    Represent the simulator state.
    For implementation of get_time_step() and similar functions.
    """
    def __init__(self):
        common.control.BaseState.__init__(self)
        self.mpi_rank = 0
        self.num_processes = 1
        self.clear()
        self.t = 0.0
        self.dt = 0.0
        self.min_delay = 0.0
        self.max_delay = 0.0
    def run(self, simtime):
        self.t += simtime
        self.running = True
    def run_until(self, tstop):
        self.t = tstop
        self.running = True
    def clear(self):
        self.gid_sources = []
        self.recorders = set([])
        self.gid_counter = 0
        self.segment_counter = -1
        self.reset()
    def reset(self):
        """Reset the state of the current network to time t = 0."""
        self.running = False
        self.t = 0.0
        self.segment_counter += 1

#===================================================
# a Singleton, so only a single instance ever exists
#===================================================
state = State()
del State
